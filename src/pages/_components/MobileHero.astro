---
import MainContainer from "./MainContainer.astro";
---

<section class="pt-16 lg:hidden">
  <MainContainer>
    <div class="max-w-fit mx-auto flex flex-col">
      <p class="w-fit ps-1 text-xs text-zinc-600 font-mono uppercase mb-1.5">
        Software Engineer
      </p>
      <h1 class="uppercase text-4xl font-semibold">Oghenetefa Okotete</h1>

      <!-- NB: 42ch equivalent to the h1 content length -->
      <div
        class="order-first p-1 rounded-xl h-12 w-[13ch] mb-3 min-[480px]:order-last min-[480px]:w-[42ch] min-[480px]:mx-auto min-[480px]:h-20 min-[480px]:mt-1 overflow-hidden" 
      >
        <div
          id="headshot-wrap"
          class="size-full overflow-hidden rounded-xl relative"
        >
          <img
            id="expectedHeadshot"
            src="/me/headshot-youth.jpg"
            alt="$whoami"
            width="50"
            height="50"
            class="size-full object-cover block object-center"
          />

          <img
            id="ghostHeadshot"
            src="/me/headshot-rebel.jpg"
            alt="ghost"
            width="50"
            height="50"
            class="size-full object-cover absolute inset-0"
            style="opacity:1; transition: opacity 600ms ease-in-out;"
          />
        </div>
      </div>
    </div>
  </MainContainer>
</section>

<style>
  .text-stroke {
    color: transparent;
    -webkit-text-fill-color: transparent;
    -webkit-text-stroke-width: var(--stroke-width, 2px);
    -webkit-text-stroke-color: var(--stroke-color, crimson);
    text-stroke: var(--stroke-width, 2px) var(--stroke-color, crimson);
  }
</style>

<script>
  import { PowerGlitch } from "powerglitch";
  import type { PowerGlitchOptions } from "powerglitch";

  const effectDelayMs = 2000;
  const glitchOptions: PowerGlitchOptions = {
    playMode: "always",
    optimizeSeo: true,
    createContainers: true,
    hideOverflow: false,
    timing: {
      duration: 1500,
      iterations: 1,
    },
    glitchTimeSpan: {
      start: 0.2,
      end: 0.8,
    },
    shake: {
      velocity: 15,
      amplitudeX: 0.2,
      amplitudeY: 0.2,
    },
    slice: {
      count: 6,
      velocity: 15,
      minHeight: 0.02,
      maxHeight: 0.15,
      hueRotate: true,
      cssFilters: "",
    },
    pulse: false,
  };

  const glitchOptionsLongedByMs = (
    delay: number,
    options: PowerGlitchOptions
  ) => {
    const defaultGlitch = PowerGlitch.getDefaultOptions();
    const glitch = {
      ...options,
      timing: {
        ...defaultGlitch.timing,
        ...options?.timing,
      },
    };

    glitch.timing.duration += delay;
    return glitch;
  };

  document.addEventListener("DOMContentLoaded", () => {
    const ghost = document.getElementById("ghostHeadshot");
    const expected = document.getElementById("expectedHeadshot");
    const wrap = document.getElementById("headshot-wrap");
    const triggersNodeList = document.querySelectorAll(".mastermind_jumpscare");
    const triggers = Array.from(triggersNodeList || []);
    const isValidTiming =
      glitchOptions.timing &&
      typeof glitchOptions.timing.duration === "number" &&
      typeof glitchOptions.timing.iterations === "number";

    if (
      !ghost ||
      !expected ||
      !wrap ||
      triggers.length === 0 ||
      !isValidTiming
    ) {
      return;
    }

    ghost.style.opacity = "1";
    ghost.style.transitionDuration = "0ms";
    const expectedRemainInViewDurationMs = 1000;

    const triggerJumpScare = () => {
      try {
        PowerGlitch.glitch("#ghostHeadshot", glitchOptions);
        PowerGlitch.glitch(
          "#expectedHeadshot",
          glitchOptionsLongedByMs(expectedRemainInViewDurationMs, glitchOptions)
        );
      } catch (e) {
        console.warn("PowerGlitch failed:", e);
      }

      const bufferMs = 0;
      let totalGlitchAnimationDurationMs =
        glitchOptions.timing.duration * glitchOptions.timing.iterations;

      setTimeout(
        () => {
          // trigger fade-out to reveal expected image underneath
          requestAnimationFrame(() => {
            ghost.style.opacity = "0";
          });
        },

        totalGlitchAnimationDurationMs +
          Math.min(bufferMs, expectedRemainInViewDurationMs)
      );

      // remove ghost node after transition completes to stop glitch artifacts and free memory
      ghost.addEventListener(
        "transitionend",
        () => {
          console.log("wtffff");
          try {
            ghost.remove();
          } catch (e) {
            /* no-op */
          }
        },
        { once: true }
      );
    };

    triggers.forEach((trigger) => {
      const onEvent = () => {
        triggerJumpScare();
      };

      trigger.addEventListener("click", onEvent);
      trigger.addEventListener("mouseenter", onEvent);
    });

    setTimeout(() => {
      triggerJumpScare();
    }, effectDelayMs);
  });
</script>
